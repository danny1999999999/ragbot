#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
user_manager.py - Â¢ûÂº∑ÁâàÁî®Êà∂ÁÆ°ÁêÜÂô®
ÊîØÊåÅÊï∏ÊìöÂ∫´ÊäΩË±°Â±§ÔºåÂêåÊôÇ‰øùÊåÅÂÆåÂÖ®ÂêëÂæåÂÖºÂÆπ
"""

import hashlib
import sqlite3
import os
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
from dataclasses import dataclass
from contextlib import contextmanager
import threading

# üîß ÂòóË©¶Â∞éÂÖ•ÊäΩË±°Â±§ÔºåÂ¶ÇÊûúÂ§±ÊïóÂâá‰ΩøÁî®ÂÇ≥Áµ±Ê®°Âºè
ADAPTER_AVAILABLE = False
try:
    from database_adapter import DatabaseAdapter, DatabaseFactory, SQLDialect
    ADAPTER_AVAILABLE = True
    print("‚úÖ Êï∏ÊìöÂ∫´ÊäΩË±°Â±§ÂèØÁî®")
except ImportError:
    print("üì¶ Êï∏ÊìöÂ∫´ÊäΩË±°Â±§‰∏çÂèØÁî®Ôºå‰ΩøÁî®ÂÇ≥Áµ± SQLite Ê®°Âºè")

# ÂÆâÂÖ®ÁöÑ print ÂáΩÊï∏
def safe_print(*args, **kwargs):
    """ÂÆâÂÖ®ÁöÑ print ÂáΩÊï∏ÔºåËôïÁêÜÁ∑®Á¢ºÂïèÈ°å"""
    try:
        print(*args, **kwargs)
    except UnicodeEncodeError:
        import sys
        try:
            for arg in args:
                sys.stdout.buffer.write(str(arg).encode('utf-8', errors='replace'))
                sys.stdout.buffer.write(b' ')
            sys.stdout.buffer.write(b'\n')
            sys.stdout.flush()
        except:
            safe_args = [str(arg).encode('ascii', errors='replace').decode('ascii') for arg in args]
            print(*safe_args, **kwargs)

import sys
from pathlib import Path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))
from config import app_config  # ‚≠ê Áµ±‰∏ÄÂ∞éÂÖ•


@dataclass
class User:
    """Áî®Êà∂Êï∏ÊìöÈ°û - ÂÆåÂÖ®ÂêëÂæåÂÖºÂÆπ"""
    username: str
    email: str
    password_hash: str
    role: str
    id: int = 0
    is_active: bool = True
    created_at: str = ""
    last_login: str = ""
    failed_attempts: int = 0  # Â∞çÊáâË≥áÊñôÂ∫´ÁöÑ failed_attempts
    locked_until: str = ""    # Â∞çÊáâË≥áÊñôÂ∫´ÁöÑ locked_until
    
    # ÁÇ∫‰∫ÜÂêë‰∏ãÁõ∏ÂÆπÔºåÊèê‰æõ login_attempts Â±¨ÊÄß
    @property
    def login_attempts(self):
        return self.failed_attempts
    
    @login_attempts.setter
    def login_attempts(self, value):
        self.failed_attempts = value
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()

    def to_dict(self) -> Dict[str, Any]:
        """Â∞áÁî®Êà∂Êï∏ÊìöËΩâÊèõÁÇ∫Â≠óÂÖ∏Ôºå‰ª•‰æøÂú® API ‰∏≠‰ΩøÁî®"""
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "role": self.role,
            "is_active": self.is_active
        }

@dataclass
class Session:
    """Session Êï∏ÊìöÈ°û"""
    id: int = 0
    user_id: int = 0
    token: str = ""
    created_at: str = ""
    expires_at: str = ""
    is_active: bool = True
    ip_address: str = ""
    user_agent: str = ""

@dataclass
class AuditLog:
    """ÂØ©Ë®àÊó•Ë™åÊï∏ÊìöÈ°û"""
    id: int = 0
    user_id: int = 0
    action: str = ""
    details: str = ""
    ip_address: str = ""
    timestamp: str = ""

class CompatibleUserManager:
    """Â¢ûÂº∑ÁâàÁî®Êà∂ÁÆ°ÁêÜÂô® - ÊîØÊåÅÊäΩË±°Â±§ÔºåÂÆåÂÖ®ÂêëÂæåÂÖºÂÆπ"""
    
    def __init__(self, db_file: str = "user_management.db"):
        """
        ÂàùÂßãÂåñÁî®Êà∂ÁÆ°ÁêÜÂô®
        
        Args:
            db_file: Êï∏ÊìöÂ∫´Êñá‰ª∂Ë∑ØÂæëÔºàÂÉÖÂú® SQLite Ê®°Âºè‰∏ã‰ΩøÁî®Ôºâ
        """
        self.db_file = db_file
        self.lock = threading.RLock()
        
        # üîß Ê±∫ÂÆö‰ΩøÁî®Âì™Á®ÆÊ®°Âºè (Êñ∞ÁâàÈÇèËºØÔºöÂÅµÊ∏¨Âà∞RailwayÁí∞Â¢ÉÊôÇÂº∑Âà∂‰ΩøÁî®Adapter)
        is_railway = bool(os.getenv('RAILWAY_PROJECT_ID'))
        use_adapter_env = os.getenv("USE_DATABASE_ADAPTER", "false").lower() == "true"
        
        if (use_adapter_env or is_railway) and ADAPTER_AVAILABLE:
            self._init_with_adapter()
        else:
            self._init_traditional_sqlite()
    
    def _init_with_adapter(self):
        """‰ΩøÁî®ÊäΩË±°Â±§ÂàùÂßãÂåñ"""
        try:
            safe_print("üîÑ ‰ΩøÁî®Êï∏ÊìöÂ∫´ÊäΩË±°Â±§Ê®°ÂºèÂàùÂßãÂåñ...")
            self.mode = "adapter"
            
            # ÂæûÁí∞Â¢ÉËÆäÊï∏ÂâµÂª∫ÈÅ©ÈÖçÂô®
            try:
                self.db = DatabaseFactory.create_from_env("user_management")
            except Exception as e:
                safe_print(f"‚ö†Ô∏è ÁÑ°Ê≥ïÂæûÁí∞Â¢ÉËÆäÊï∏ÂâµÂª∫ÈÅ©ÈÖçÂô®Ôºå‰ΩøÁî®ÈªòË™ç SQLite: {e}")
                # ÂõûÈÄÄÂà∞ SQLite
                self.db = DatabaseFactory.create_adapter("sqlite", {
                    "db_file": self.db_file
                })
            
            # ÈÄ£Êé•‰∏¶ÂàùÂßãÂåñÊï∏ÊìöÂ∫´
            self.db.connect()
            self._create_database_schema_adapter()
            self._verify_and_migrate_schema_adapter()
            self._create_default_admin()
            safe_print("‚úÖ Áî®Êà∂ÁÆ°ÁêÜÂô®ÂàùÂßãÂåñÊàêÂäüÔºàÊäΩË±°Â±§Ê®°ÂºèÔºâ")
            
        except Exception as e:
            safe_print(f"‚ùå ÊäΩË±°Â±§ÂàùÂßãÂåñÂ§±ÊïóÔºåÂõûÈÄÄÂà∞ÂÇ≥Áµ±Ê®°Âºè: {e}")
            self._init_traditional_sqlite()
    
    def _init_traditional_sqlite(self):
        """‰ΩøÁî®ÂÇ≥Áµ± SQLite ÂàùÂßãÂåñ"""
        safe_print("üì¶ ‰ΩøÁî®ÂÇ≥Áµ± SQLite Ê®°ÂºèÂàùÂßãÂåñ...")
        self.mode = "traditional"
        self.db = None
        
        # Â¶ÇÊûúË≥áÊñôÂ∫´‰∏çÂ≠òÂú®ÔºåÂâµÂª∫‰∏ÄÂÄã
        if not os.path.exists(self.db_file):
            safe_print(f"‚ö†Ô∏è Ë≥áÊñôÂ∫´Ê™îÊ°à‰∏çÂ≠òÂú®ÔºåÂ∞áÂâµÂª∫Êñ∞ÁöÑË≥áÊñôÂ∫´: {self.db_file}")
            self._create_database_traditional()
        else:
            safe_print(f"‚úÖ ÈÄ£Êé•Âà∞ÁèæÊúâË≥áÊñôÂ∫´: {self.db_file}")
        
        self._verify_database_structure_traditional()
        safe_print("‚úÖ Áî®Êà∂ÁÆ°ÁêÜÂô®ÂàùÂßãÂåñÊàêÂäüÔºàÂÇ≥Áµ±Ê®°ÂºèÔºâ")
    
    # ========== ÊäΩË±°Â±§Ê®°ÂºèÁöÑÊñπÊ≥ï ==========
    
    def _get_db_type(self) -> str:
        """Áç≤ÂèñÊï∏ÊìöÂ∫´È°ûÂûãÔºàÊäΩË±°Â±§Ê®°ÂºèÔºâ"""
        if self.mode == "adapter":
            return type(self.db).__name__.replace("Adapter", "").lower()
        return "sqlite"
    
    def _create_database_schema_adapter(self):
        """ÂâµÂª∫Êï∏ÊìöÂ∫´Ê®°ÂºèÔºàÊäΩË±°Â±§Ê®°ÂºèÔºâ"""
        try:
            db_type = self._get_db_type()
            
            if db_type == "sqlite":
                users_table_sql = '''
                    CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username TEXT UNIQUE NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        password_hash TEXT NOT NULL,
                        role TEXT DEFAULT 'user',
                        is_active BOOLEAN DEFAULT 1,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                        last_login TEXT,
                        failed_attempts INTEGER DEFAULT 0,
                        locked_until TEXT
                    )
                '''
                
                sessions_table_sql = '''
                    CREATE TABLE IF NOT EXISTS sessions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        token TEXT UNIQUE NOT NULL,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                        expires_at TEXT NOT NULL,
                        is_active BOOLEAN DEFAULT 1,
                        ip_address TEXT,
                        user_agent TEXT,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                '''
                
                audit_logs_table_sql = '''
                    CREATE TABLE IF NOT EXISTS audit_logs (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        action TEXT NOT NULL,
                        details TEXT,
                        ip_address TEXT,
                        timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                '''
            
            elif db_type == "postgresql":
                users_table_sql = '''
                    CREATE TABLE IF NOT EXISTS users (
                        id SERIAL PRIMARY KEY,
                        username VARCHAR(255) UNIQUE NOT NULL,
                        email VARCHAR(255) UNIQUE NOT NULL,
                        password_hash VARCHAR(255) NOT NULL,
                        role VARCHAR(50) DEFAULT 'user',
                        is_active BOOLEAN DEFAULT TRUE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login VARCHAR(255),
                        failed_attempts INTEGER DEFAULT 0,
                        locked_until VARCHAR(255)
                    )
                '''
                
                sessions_table_sql = '''
                    CREATE TABLE IF NOT EXISTS sessions (
                        id SERIAL PRIMARY KEY,
                        user_id INTEGER NOT NULL,
                        token VARCHAR(512) UNIQUE NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        expires_at VARCHAR(255) NOT NULL,
                        is_active BOOLEAN DEFAULT TRUE,
                        ip_address VARCHAR(45),
                        user_agent TEXT,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                '''
                
                audit_logs_table_sql = '''
                    CREATE TABLE IF NOT EXISTS audit_logs (
                        id SERIAL PRIMARY KEY,
                        user_id INTEGER NOT NULL,
                        action VARCHAR(100) NOT NULL,
                        details TEXT,
                        ip_address VARCHAR(45),
                        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                '''
            else:
                raise ValueError(f"‰∏çÊîØÊè¥ÁöÑÊï∏ÊìöÂ∫´È°ûÂûã: {db_type}")
            
            # Âü∑Ë°åÂâµÂª∫Ë™ûÂè•
            with self.db.transaction():
                self.db.execute_update(users_table_sql)
                self.db.execute_update(sessions_table_sql)
                self.db.execute_update(audit_logs_table_sql)
            
        except Exception as e:
            safe_print(f"‚ùå ÂâµÂª∫Êï∏ÊìöÂ∫´Ê®°ÂºèÂ§±Êïó: {e}")
            raise
    
    def _verify_and_migrate_schema_adapter(self):
        """È©óË≠â‰∏¶ÈÅ∑ÁßªÊï∏ÊìöÂ∫´Ê®°ÂºèÔºàÊäΩË±°Â±§Ê®°ÂºèÔºâ"""
        try:
            # Ê™¢Êü•ÂøÖË¶ÅÁöÑË°®Ê†º
            required_tables = ['users', 'sessions', 'audit_logs']
            
            for table in required_tables:
                if not self.db.table_exists(table):
                    safe_print(f"‚ö†Ô∏è Ë°®Ê†º {table} ‰∏çÂ≠òÂú®ÔºåÈáçÊñ∞ÂâµÂª∫...")
                    self._create_database_schema_adapter()
                    break
            
            # Ê™¢Êü•Áî®Êà∂Ë°®ÁöÑÂøÖË¶ÅÂàó
            user_columns = self.db.get_table_columns('users')
            required_columns = [
                'id', 'username', 'email', 'password_hash', 'role',
                'is_active', 'created_at', 'last_login', 'failed_attempts', 'locked_until'
            ]
            
            missing_columns = [col for col in required_columns if col not in user_columns]
            
            if missing_columns:
                safe_print(f"‚ö†Ô∏è Áî®Êà∂Ë°®Áº∫Â∞ëÂàó: {missing_columns}")
                self._add_missing_columns_adapter(missing_columns)
                
        except Exception as e:
            safe_print(f"‚ùå Êï∏ÊìöÂ∫´Ê®°ÂºèÈ©óË≠âÂ§±Êïó: {e}")
    
    def _add_missing_columns_adapter(self, missing_columns: List[str]):
        """Ê∑ªÂä†Áº∫Â§±ÁöÑÂàóÔºàÊäΩË±°Â±§Ê®°ÂºèÔºâ"""
        try:
            db_type = self._get_db_type()
            column_definitions = {
                'failed_attempts': 'INTEGER DEFAULT 0',
                'locked_until': 'TEXT' if db_type == 'sqlite' else 'VARCHAR(255)',
                'last_login': 'TEXT' if db_type == 'sqlite' else 'VARCHAR(255)',
                'is_active': 'BOOLEAN DEFAULT 1' if db_type == 'sqlite' else 'BOOLEAN DEFAULT TRUE',
                'role': 'TEXT DEFAULT "user"' if db_type == 'sqlite' else 'VARCHAR(50) DEFAULT \'user\''
            }
            
            for column in missing_columns:
                if column in column_definitions:
                    try:
                        self.db.execute_update(f"ALTER TABLE users ADD COLUMN {column} {column_definitions[column]}")
                        safe_print(f"‚úÖ Ê∑ªÂä†Âàó: {column}")
                    except Exception as e:
                        safe_print(f"‚ö†Ô∏è Ê∑ªÂä†Âàó {column} Â§±Êïó: {e}")
        except Exception as e:
            safe_print(f"‚ùå Ê∑ªÂä†Áº∫Â§±ÂàóÂ§±Êïó: {e}")
    
    # ========== ÂÇ≥Áµ±Ê®°ÂºèÁöÑÊñπÊ≥ï ==========
    
    def _create_database_traditional(self):
        """ÂâµÂª∫Êñ∞ÁöÑË≥áÊñôÂ∫´ÂíåË°®Ê†ºÔºàÂÇ≥Áµ±Ê®°ÂºèÔºâ"""
        try:
            with sqlite3.connect(self.db_file) as conn:
                cursor = conn.cursor()
                
                # ÂâµÂª∫ users Ë°®
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username TEXT UNIQUE NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        password_hash TEXT NOT NULL,
                        role TEXT DEFAULT 'user',
                        is_active BOOLEAN DEFAULT 1,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                        last_login TEXT,
                        failed_attempts INTEGER DEFAULT 0,
                        locked_until TEXT
                    )
                ''')
                
                # ÂâµÂª∫ sessions Ë°®
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS sessions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        token TEXT UNIQUE NOT NULL,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                        expires_at TEXT NOT NULL,
                        is_active BOOLEAN DEFAULT 1,
                        ip_address TEXT,
                        user_agent TEXT,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                ''')
                
                # ÂâµÂª∫ audit_logs Ë°®
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS audit_logs (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        action TEXT NOT NULL,
                        details TEXT,
                        ip_address TEXT,
                        timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                ''')
                
                conn.commit()
                
                # ÂâµÂª∫ÈªòË™çÁÆ°ÁêÜÂì°
                self._create_default_admin()
                
                safe_print("‚úÖ Ë≥áÊñôÂ∫´ÂíåË°®Ê†ºÂâµÂª∫ÊàêÂäü")
                
        except Exception as e:
            safe_print(f"‚ùå ÂâµÂª∫Ë≥áÊñôÂ∫´Â§±Êïó: {e}")
            raise
    
    def _verify_database_structure_traditional(self):
        """È©óË≠â‰∏¶‰øÆÂæ©Ë≥áÊñôÂ∫´ÁµêÊßãÔºàÂÇ≥Áµ±Ê®°ÂºèÔºâ"""
        try:
            with sqlite3.connect(self.db_file) as conn:
                cursor = conn.cursor()
                
                # ÂÆöÁæ©ÊâÄÊúâÊáâÊúâÁöÑÊ¨Ñ‰ΩçÂèäÂÖ∂È°ûÂûã
                required_columns = {
                    'id': 'INTEGER PRIMARY KEY AUTOINCREMENT',
                    'username': 'TEXT UNIQUE NOT NULL',
                    'email': 'TEXT UNIQUE NOT NULL', 
                    'password_hash': 'TEXT NOT NULL',
                    'role': 'TEXT DEFAULT "user"',
                    'is_active': 'BOOLEAN DEFAULT 1',
                    'created_at': 'TEXT DEFAULT CURRENT_TIMESTAMP',
                    'last_login': 'TEXT',
                    'failed_attempts': 'INTEGER DEFAULT 0',
                    'locked_until': 'TEXT'
                }
                
                # Ê™¢Êü•ÁèæÊúâÊ¨Ñ‰Ωç
                cursor.execute("PRAGMA table_info(users)")
                existing_columns = {column[1] for column in cursor.fetchall()}
                
                # Ê∑ªÂä†Áº∫Â§±ÁöÑÊ¨Ñ‰Ωç
                for col_name, col_type in required_columns.items():
                    if col_name not in existing_columns:
                        safe_print(f"‚ö†Ô∏è Ê™¢Ê∏¨Âà∞Áº∫Â§±ÁöÑË≥áÊñôÂ∫´Ê¨Ñ‰ΩçÔºåÊ≠£Âú®Ëá™ÂãïÊñ∞Â¢û: {col_name}")
                        try:
                            cursor.execute(f'ALTER TABLE users ADD COLUMN {col_name} {col_type}')
                        except Exception as e:
                            safe_print(f"‚ö†Ô∏è Êñ∞Â¢ûÊ¨Ñ‰Ωç {col_name} Â§±Êïó: {e}")
                
                conn.commit()
                safe_print("‚úÖ Ë≥áÊñôÂ∫´ÁµêÊßãÈ©óË≠âÈÄöÈÅé")
                
        except Exception as e:
            safe_print(f"‚ùå Ë≥áÊñôÂ∫´ÁµêÊßãÈ©óË≠âÂ§±Êïó: {e}")
    
    @contextmanager
    def _get_db_connection(self):
        """Áç≤ÂèñË≥áÊñôÂ∫´ÈÄ£Êé•Ôºà‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÔºåÂÇ≥Áµ±Ê®°ÂºèÔºâ"""
        conn = sqlite3.connect(self.db_file)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()
    
    # ========== Áµ±‰∏ÄÁöÑÂÖ¨ÂÖ±ÊñπÊ≥ï ==========
    
    def _create_default_admin(self):
        """ÂâµÂª∫ÈªòË™çÁÆ°ÁêÜÂì°Áî®Êà∂"""
        try:
            # Ê™¢Êü•ÊòØÂê¶Â∑≤ÊúâÁÆ°ÁêÜÂì°
            if self.mode == "adapter":
                results = self.db.execute_query(
                    "SELECT COUNT(*) as count FROM users WHERE role IN ('admin', 'super_admin')"
                )
                admin_count = results[0]['count'] if results else 0
            else:
                with self._get_db_connection() as conn:
                    cursor = conn.execute("SELECT COUNT(*) FROM users WHERE role IN ('admin', 'super_admin')")
                    admin_count = cursor.fetchone()[0]
            
            if admin_count == 0:
                # ÂâµÂª∫ÈªòË™çÁÆ°ÁêÜÂì°
                admin_password = os.getenv("ADMIN_PASSWORD", "ggyyggyyggyy")
                admin_user = User(
                    username="admin",
                    email="admin@example.com",
                    password_hash=self.hash_password(admin_password),
                    role="super_admin",
                    is_active=True
                )
                
                user_id = self.create_user(admin_user)
                if user_id:
                    safe_print(f"‚úÖ ÈªòË™çÁÆ°ÁêÜÂì°ÂâµÂª∫ÊàêÂäü (Áî®Êà∂Âêç: admin, ÂØÜÁ¢º: {admin_password})")
                else:
                    safe_print("‚ö†Ô∏è ÈªòË™çÁÆ°ÁêÜÂì°ÂâµÂª∫Â§±Êïó")
            else:
                safe_print("‚ÑπÔ∏è Â∑≤Â≠òÂú®ÁÆ°ÁêÜÂì°Áî®Êà∂ÔºåË∑≥ÈÅéÂâµÂª∫ÈªòË™çÁÆ°ÁêÜÂì°")
                
        except Exception as e:
            safe_print(f"‚ö†Ô∏è ÂâµÂª∫ÈªòË™çÁÆ°ÁêÜÂì°Â§±Êïó: {e}")
    
    def hash_password(self, password: str) -> str:
        """ÂØÜÁ¢ºÈõúÊπä - ‰ΩøÁî® atalantis Â∞àÁî®ÈπΩÂÄº"""
        salt = "atalantis-salt-2025"
        return hashlib.sha256((password + salt).encode()).hexdigest()
    
    def verify_password(self, password: str, password_hash: str) -> bool:
        """È©óË≠âÂØÜÁ¢º"""
        return self.hash_password(password) == password_hash
    
    def get_user_by_username(self, username: str) -> Optional[User]:
        """Ê†πÊìöÁî®Êà∂ÂêçÁç≤ÂèñÁî®Êà∂"""
        with self.lock:
            try:
                if self.mode == "adapter":
                    results = self.db.execute_query(
                        'SELECT * FROM users WHERE username = ?', (username,)
                    )
                    if results:
                        user_data = results[0]
                        return User(**user_data)
                else:
                    with self._get_db_connection() as conn:
                        row = conn.execute(
                            'SELECT * FROM users WHERE username = ?', (username,)
                        ).fetchone()
                        if row:
                            user_data = dict(row)
                            return User(**user_data)
                return None
                
            except Exception as e:
                safe_print(f"‚ùå Áç≤ÂèñÁî®Êà∂Â§±Êïó: {e}")
                return None
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        """Ê†πÊìö ID Áç≤ÂèñÁî®Êà∂"""
        with self.lock:
            try:
                if self.mode == "adapter":
                    results = self.db.execute_query(
                        'SELECT * FROM users WHERE id = ?', (user_id,)
                    )
                    if results:
                        user_data = results[0]
                        return User(**user_data)
                else:
                    with self._get_db_connection() as conn:
                        row = conn.execute(
                            'SELECT * FROM users WHERE id = ?', (user_id,)
                        ).fetchone()
                        if row:
                            user_data = dict(row)
                            return User(**user_data)
                return None
                
            except Exception as e:
                safe_print(f"‚ùå Áç≤ÂèñÁî®Êà∂Â§±Êïó: {e}")
                return None
    
    def get_user_by_email(self, email: str) -> Optional[User]:
        """Ê†πÊìöÈÉµÁÆ±Áç≤ÂèñÁî®Êà∂"""
        with self.lock:
            try:
                if self.mode == "adapter":
                    results = self.db.execute_query(
                        'SELECT * FROM users WHERE email = ?', (email,)
                    )
                    if results:
                        user_data = results[0]
                        return User(**user_data)
                else:
                    with self._get_db_connection() as conn:
                        row = conn.execute(
                            'SELECT * FROM users WHERE email = ?', (email,)
                        ).fetchone()
                        if row:
                            user_data = dict(row)
                            return User(**user_data)
                return None
                
            except Exception as e:
                safe_print(f"‚ùå Áç≤ÂèñÁî®Êà∂Â§±Êïó: {e}")
                return None
    
    def create_user(self, user: User) -> Optional[int]:
        """ÂâµÂª∫Êñ∞Áî®Êà∂"""
        with self.lock:
            try:
                # Ê™¢Êü•Áî®Êà∂ÂêçÂíåÈÉµÁÆ±ÊòØÂê¶Â∑≤Â≠òÂú®
                if self.get_user_by_username(user.username) or self.get_user_by_email(user.email):
                    return None
                
                user.created_at = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                
                if self.mode == "adapter":
                    user_id = self.db.execute_insert('''
                        INSERT INTO users (username, email, password_hash, role, is_active, created_at, failed_attempts)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                    ''', (user.username, user.email, user.password_hash, user.role, 
                          user.is_active, user.created_at, user.failed_attempts))
                else:
                    with self._get_db_connection() as conn:
                        cursor = conn.execute('''
                            INSERT INTO users (username, email, password_hash, role, is_active, created_at, failed_attempts)
                            VALUES (?, ?, ?, ?, ?, ?, ?)
                        ''', (user.username, user.email, user.password_hash, user.role, 
                              user.is_active, user.created_at, user.failed_attempts))
                        user_id = cursor.lastrowid
                        conn.commit()
                
                if user_id:
                    user.id = user_id
                    self.log_audit(user.id, "user_created", f"Êñ∞Áî®Êà∂Ë®ªÂÜä: {user.username}")
                
                return user_id
                
            except Exception as e:
                safe_print(f"‚ùå ÂâµÂª∫Áî®Êà∂Â§±Êïó: {e}")
                return None
    
    def update_user(self, user_id: int, updates: Dict[str, Any]) -> bool:
        """Êõ¥Êñ∞Áî®Êà∂‰ø°ÊÅØ"""
        with self.lock:
            try:
                # ÊßãÂª∫ÂãïÊÖã UPDATE Ë™ûÂè•
                set_clauses = []
                values = []
                
                # Êò†Â∞ÑÂ≠óÊÆµÂêçÁ®±Ôºàlogin_attempts -> failed_attemptsÔºâ
                field_mapping = {
                    'login_attempts': 'failed_attempts'
                }
                
                allowed_fields = [
                    'username', 'email', 'password_hash', 'role', 'is_active', 
                    'last_login', 'failed_attempts', 'locked_until'
                ]
                
                for key, value in updates.items():
                    db_field = field_mapping.get(key, key)
                    if db_field in allowed_fields:
                        set_clauses.append(f"{db_field} = ?")
                        values.append(value)
                
                if not set_clauses:
                    return False
                
                values.append(user_id)
                
                if self.mode == "adapter":
                    affected_rows = self.db.execute_update(
                        f"UPDATE users SET {', '.join(set_clauses)} WHERE id = ?",
                        values
                    )
                else:
                    with self._get_db_connection() as conn:
                        cursor = conn.execute(
                            f"UPDATE users SET {', '.join(set_clauses)} WHERE id = ?",
                            values
                        )
                        affected_rows = cursor.rowcount
                        conn.commit()
                
                if affected_rows > 0:
                    self.log_audit(user_id, "user_updated", f"Áî®Êà∂Ë≥áÊñôÊõ¥Êñ∞: {list(updates.keys())}")
                    return True
                
                return False
                
            except Exception as e:
                safe_print(f"‚ùå Êõ¥Êñ∞Áî®Êà∂Â§±Êïó: {e}")
                return False
    
    def delete_user(self, user_id: int) -> bool:
        """Âà™Èô§Áî®Êà∂ÔºàËªüÂà™Èô§ - Ë®≠ÁÇ∫ÂÅúÁî®Ôºâ"""
        try:
            return self.update_user(user_id, {"is_active": False})
        except Exception as e:
            safe_print(f"‚ùå Âà™Èô§Áî®Êà∂Â§±Êïó: {e}")
            return False
    
    def authenticate(self, username: str, password: str, ip_address: str = "") -> tuple[bool, str, Optional[User]]:
        """Áî®Êà∂Ë™çË≠â"""
        user = self.get_user_by_username(username)
        
        if not user:
            self.log_audit(0, "login_failed", f"Áî®Êà∂‰∏çÂ≠òÂú®: {username}", ip_address)
            return False, "Áî®Êà∂‰∏çÂ≠òÂú®", None
        
        if not user.is_active:
            self.log_audit(user.id, "login_failed", f"Â∏≥Êà∂Â∑≤ÂÅúÁî®", ip_address)
            return False, "Â∏≥Êà∂Â∑≤Ë¢´ÂÅúÁî®", None
        
        # Ê™¢Êü•ÊòØÂê¶Ë¢´ÈéñÂÆö
        if user.locked_until:
            try:
                locked_until = datetime.fromisoformat(user.locked_until.replace('Z', '+00:00'))
                if datetime.now() < locked_until:
                    self.log_audit(user.id, "login_failed", f"Â∏≥Êà∂Ë¢´ÈéñÂÆö", ip_address)
                    return False, f"Â∏≥Êà∂Ë¢´ÈéñÂÆöËá≥ {user.locked_until}", None
            except:
                pass
        
        if not self.verify_password(password, user.password_hash):
            # Â¢ûÂä†ÁôªÂÖ•Â§±ÊïóÊ¨°Êï∏
            new_attempts = user.failed_attempts + 1
            updates = {"failed_attempts": new_attempts}
            
            if new_attempts >= 5:
                # ÈéñÂÆöÂ∏≥Êà∂1Â∞èÊôÇ
                locked_until = (datetime.now() + timedelta(hours=1)).isoformat()
                updates["locked_until"] = locked_until
                updates["is_active"] = False
                self.log_audit(user.id, "account_locked", f"ÁôªÂÖ•Â§±ÊïóÊ¨°Êï∏ÈÅéÂ§ö", ip_address)
            
            self.update_user(user.id, updates)
            return False, "ÂØÜÁ¢ºÈåØË™§", None
        
        # ÁôªÂÖ•ÊàêÂäü
        self.update_user(user.id, {
            "last_login": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "failed_attempts": 0,
            "locked_until": None,
            "is_active": True
        })
        
        # ÁîüÊàê token
        token = self._generate_token(user, ip_address)
        
        self.log_audit(user.id, "login_success", f"ÊàêÂäüÁôªÂÖ•", ip_address)
        
        return True, token, user
    
    def _generate_token(self, user: User, ip_address: str = "") -> str:
        """ÁîüÊàê session token"""
        try:
            import jwt
            
            secret_key = os.getenv("JWT_SECRET_KEY", "your-super-secret-key-change-this")
            
            # ÁîüÊàê JWT token
            token_data = {
                "user_id": user.id,
                "username": user.username,
                "role": user.role,
                "iat": datetime.utcnow().timestamp(),
                "exp": (datetime.utcnow() + timedelta(hours=24)).timestamp()
            }
            
            token = jwt.encode(token_data, secret_key, algorithm="HS256")
            
            # ‰øùÂ≠òÂà∞ sessions Ë°®
            expires_at = (datetime.now() + timedelta(hours=24)).isoformat()
            
            if self.mode == "adapter":
                self.db.execute_insert('''
                    INSERT INTO sessions (user_id, token, created_at, expires_at, ip_address)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user.id, token, datetime.now().strftime('%Y-%m-%d %H:%M:%S'), expires_at, ip_address))
            else:
                with self._get_db_connection() as conn:
                    conn.execute('''
                        INSERT INTO sessions (user_id, token, created_at, expires_at, ip_address)
                        VALUES (?, ?, ?, ?, ?)
                    ''', (user.id, token, datetime.now().strftime('%Y-%m-%d %H:%M:%S'), expires_at, ip_address))
                    conn.commit()
            
            return token
            
        except ImportError:
            # Â¶ÇÊûúÊ≤íÊúâ jwt Â∫´ÔºåÁîüÊàêÁ∞°ÂñÆ token
            import uuid
            token = str(uuid.uuid4())
            
            expires_at = (datetime.now() + timedelta(hours=24)).isoformat()
            
            if self.mode == "adapter":
                self.db.execute_insert('''
                    INSERT INTO sessions (user_id, token, created_at, expires_at, ip_address)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user.id, token, datetime.now().strftime('%Y-%m-%d %H:%M:%S'), expires_at, ip_address))
            else:
                with self._get_db_connection() as conn:
                    conn.execute('''
                        INSERT INTO sessions (user_id, token, created_at, expires_at, ip_address)
                        VALUES (?, ?, ?, ?, ?)
                    ''', (user.id, token, datetime.now().strftime('%Y-%m-%d %H:%M:%S'), expires_at, ip_address))
                    conn.commit()
            
            return token
    
    def validate_token(self, token: str) -> Optional[User]:
        """È©óË≠â token ‰∏¶ËøîÂõûÁî®Êà∂"""
        if not token:
            return None
        
        try:
            if self.mode == "adapter":
                results = self.db.execute_query('''
                    SELECT u.* FROM users u 
                    JOIN sessions s ON u.id = s.user_id
                    WHERE s.token = ? AND s.is_active = 1 AND s.expires_at > ?
                ''', (token, datetime.now().isoformat()))
                
                if results:
                    user_data = results[0]
                    return User(**user_data)
            else:
                with self._get_db_connection() as conn:
                    row = conn.execute('''
                        SELECT u.* FROM users u 
                        JOIN sessions s ON u.id = s.user_id
                        WHERE s.token = ? AND s.is_active = 1 AND s.expires_at > ?
                    ''', (token, datetime.now().isoformat())).fetchone()
                    
                    if row:
                        user_data = dict(row)
                        return User(**user_data)
            return None
        except Exception as e:
            safe_print(f"‚ùå È©óË≠â token Â§±Êïó: {e}")
            return None
    
    def logout(self, token: str) -> bool:
        """ÁôªÂá∫Ôºà‰Ωø token Â§±ÊïàÔºâ"""
        if not token:
            return False
        
        try:
            if self.mode == "adapter":
                affected_rows = self.db.execute_update(
                    'UPDATE sessions SET is_active = 0 WHERE token = ?',
                    (token,)
                )
            else:
                with self._get_db_connection() as conn:
                    cursor = conn.execute(
                        'UPDATE sessions SET is_active = 0 WHERE token = ?',
                        (token,)
                    )
                    affected_rows = cursor.rowcount
                    conn.commit()
            return affected_rows > 0
        except Exception as e:
            safe_print(f"‚ùå ÁôªÂá∫Â§±Êïó: {e}")
            return False
    
    def get_users(self, limit: int = 1000, offset: int = 0) -> List[User]:
        """Áç≤ÂèñÁî®Êà∂ÂàóË°® - Â¢ûÂä†ÈªòË™çÈôêÂà∂"""
        try:
            if self.mode == "adapter":
                results = self.db.execute_query(
                    'SELECT * FROM users ORDER BY created_at DESC LIMIT ? OFFSET ?',
                    (limit, offset)
                )
                return [User(**row) for row in results]
            else:
                with self._get_db_connection() as conn:
                    rows = conn.execute(
                        'SELECT * FROM users ORDER BY created_at DESC LIMIT ? OFFSET ?',
                        (limit, offset)
                    ).fetchall()
                    return [User(**dict(row)) for row in rows]
                    
        except Exception as e:
            safe_print(f"‚ùå Áç≤ÂèñÁî®Êà∂ÂàóË°®Â§±Êïó: {e}")
            return []
    
    def get_total_users_count(self) -> int:
        """Áç≤ÂèñÁî®Êà∂Á∏ΩÊï∏"""
        try:
            if self.mode == "adapter":
                results = self.db.execute_query('SELECT COUNT(*) as count FROM users')
                return results[0]['count'] if results else 0
            else:
                with self._get_db_connection() as conn:
                    return conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        except Exception as e:
            safe_print(f"‚ùå Áç≤ÂèñÁî®Êà∂Á∏ΩÊï∏Â§±Êïó: {e}")
            return 0
    
    def search_users(self, search_term: str, role_filter: str = "", limit: int = 100) -> List[User]:
        """ÊêúÁ¥¢Áî®Êà∂"""
        try:
            query = 'SELECT * FROM users WHERE (username LIKE ? OR email LIKE ?)'
            params = [f'%{search_term}%', f'%{search_term}%']
            
            if role_filter:
                query += ' AND role = ?'
                params.append(role_filter)
            
            query += ' ORDER BY created_at DESC LIMIT ?'
            params.append(limit)
            
            if self.mode == "adapter":
                results = self.db.execute_query(query, params)
                return [User(**row) for row in results]
            else:
                with self._get_db_connection() as conn:
                    rows = conn.execute(query, params).fetchall()
                    return [User(**dict(row)) for row in rows]
                    
        except Exception as e:
            safe_print(f"‚ùå ÊêúÁ¥¢Áî®Êà∂Â§±Êïó: {e}")
            return []
    
    def log_audit(self, user_id: int, action: str, details: str = "", ip_address: str = ""):
        """Ë®òÈåÑÂØ©Ë®àÊó•Ë™å"""
        try:
            if self.mode == "adapter":
                self.db.execute_insert('''
                    INSERT INTO audit_logs (user_id, action, details, ip_address, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user_id, action, details, ip_address, datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
            else:
                with self._get_db_connection() as conn:
                    conn.execute('''
                        INSERT INTO audit_logs (user_id, action, details, ip_address, timestamp)
                        VALUES (?, ?, ?, ?, ?)
                    ''', (user_id, action, details, ip_address, datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
                    conn.commit()
        except Exception as e:
            safe_print(f"‚ö†Ô∏è Ë®òÈåÑÂØ©Ë®àÊó•Ë™åÂ§±Êïó: {e}")
    
    def get_audit_logs(self, user_id: Optional[int] = None, limit: int = 50) -> List[Dict]:
        """Áç≤ÂèñÂØ©Ë®àÊó•Ë™å"""
        try:
            if user_id:
                query = 'SELECT * FROM audit_logs WHERE user_id = ? ORDER BY timestamp DESC LIMIT ?'
                params = (user_id, limit)
            else:
                query = 'SELECT * FROM audit_logs ORDER BY timestamp DESC LIMIT ?'
                params = (limit,)
            
            if self.mode == "adapter":
                return self.db.execute_query(query, params)
            else:
                with self._get_db_connection() as conn:
                    rows = conn.execute(query, params).fetchall()
                    return [dict(row) for row in rows]
                    
        except Exception as e:
            safe_print(f"‚ùå Áç≤ÂèñÂØ©Ë®àÊó•Ë™åÂ§±Êïó: {e}")
            return []
    
    def get_system_stats(self) -> Dict[str, Any]:
        """Áç≤ÂèñÁ≥ªÁµ±Áµ±Ë®à"""
        try:
            if self.mode == "adapter":
                # Áî®Êà∂Áµ±Ë®à
                user_stats = self.db.execute_query('''
                    SELECT 
                        COUNT(*) as total_users,
                        SUM(CASE WHEN is_active = 1 THEN 1 ELSE 0 END) as active_users,
                        SUM(CASE WHEN last_login IS NOT NULL THEN 1 ELSE 0 END) as users_with_login
                    FROM users
                ''')[0]
                
                # Session Áµ±Ë®à
                session_results = self.db.execute_query('''
                    SELECT COUNT(*) as count FROM sessions 
                    WHERE is_active = 1 AND expires_at > ?
                ''', (datetime.now().isoformat(),))
                active_sessions = session_results[0]['count'] if session_results else 0
                
                # ‰ªäÊó•ÁôªÂÖ•
                today = datetime.now().date().strftime('%Y-%m-%d')
                today_login_results = self.db.execute_query('''
                    SELECT COUNT(*) as count FROM audit_logs 
                    WHERE action = 'login_success' AND DATE(timestamp) = ?
                ''', (today,))
                today_logins = today_login_results[0]['count'] if today_login_results else 0
                
                # ËßíËâ≤Áµ±Ë®à
                role_results = self.db.execute_query('''
                    SELECT role, COUNT(*) as count 
                    FROM users 
                    WHERE is_active = 1 
                    GROUP BY role
                ''')
                role_breakdown = {row['role']: row['count'] for row in role_results}
                
                storage_type = f"{self._get_db_type()}_with_adapter"
            else:
                # ÂÇ≥Áµ±Ê®°ÂºèÁµ±Ë®à
                with self._get_db_connection() as conn:
                    # Áî®Êà∂Áµ±Ë®à
                    user_stats = conn.execute('''
                        SELECT 
                            COUNT(*) as total_users,
                            SUM(CASE WHEN is_active = 1 THEN 1 ELSE 0 END) as active_users,
                            SUM(CASE WHEN last_login IS NOT NULL THEN 1 ELSE 0 END) as users_with_login
                        FROM users
                    ''').fetchone()
                    
                    # Session Áµ±Ë®à
                    active_sessions = conn.execute('''
                        SELECT COUNT(*) FROM sessions 
                        WHERE is_active = 1 AND expires_at > ?
                    ''', (datetime.now().isoformat(),)).fetchone()[0]
                    
                    # ‰ªäÊó•ÁôªÂÖ•
                    today = datetime.now().date().strftime('%Y-%m-%d')
                    today_logins = conn.execute('''
                        SELECT COUNT(*) FROM audit_logs 
                        WHERE action = 'login_success' AND DATE(timestamp) = ?
                    ''', (today,)).fetchone()[0]
                    
                    # ËßíËâ≤Áµ±Ë®à
                    role_rows = conn.execute('''
                        SELECT role, COUNT(*) as count 
                        FROM users 
                        WHERE is_active = 1 
                        GROUP BY role
                    ''').fetchall()
                    role_breakdown = {row[0]: row[1] for row in role_rows}
                
                storage_type = "sqlite_enhanced"
            
            return {
                "total_users": user_stats['total_users'] if self.mode == "adapter" else user_stats[0],
                "active_users": user_stats['active_users'] if self.mode == "adapter" else user_stats[1],
                "inactive_users": (user_stats['total_users'] - user_stats['active_users']) if self.mode == "adapter" else (user_stats[0] - user_stats[1]),
                "users_with_login": user_stats['users_with_login'] if self.mode == "adapter" else user_stats[2],
                "active_sessions": active_sessions,
                "today_logins": today_logins,
                "role_breakdown": role_breakdown,
                "storage_type": storage_type,
                "mode": self.mode
            }
            
        except Exception as e:
            safe_print(f"‚ùå Áç≤ÂèñÁ≥ªÁµ±Áµ±Ë®àÂ§±Êïó: {e}")
            return {}
    
    def cleanup_expired_sessions(self):
        """Ê∏ÖÁêÜÈÅéÊúüÁöÑ session"""
        try:
            if self.mode == "adapter":
                affected_rows = self.db.execute_update(
                    'DELETE FROM sessions WHERE expires_at < ?',
                    (datetime.now().isoformat(),)
                )
            else:
                with self._get_db_connection() as conn:
                    cursor = conn.execute(
                        'DELETE FROM sessions WHERE expires_at < ?',
                        (datetime.now().isoformat(),)
                    )
                    affected_rows = cursor.rowcount
                    conn.commit()
            
            if affected_rows > 0:
                safe_print(f"üßπ Ê∏ÖÁêÜ‰∫Ü {affected_rows} ÂÄãÈÅéÊúü session")
        except Exception as e:
            safe_print(f"‚ùå Ê∏ÖÁêÜÈÅéÊúü session Â§±Êïó: {e}")
    
    def has_permission(self, user: User, permission: str) -> bool:
        """Ê™¢Êü•Áî®Êà∂Ê¨äÈôê"""
        if not user or not user.is_active:
            return False
        
        # Ê¨äÈôêÊò†Â∞Ñ
        role_permissions = {
            "super_admin": ["*"],  # ÊâÄÊúâÊ¨äÈôê
            "admin": ["manage_users", "view_conversations", "manage_bots", "manage_data", "view_stats"],
            "operator": ["view_conversations", "manage_bots", "view_stats"],
            "user": ["view_own_data"]
        }
        
        user_permissions = role_permissions.get(user.role, [])
        
        # super_admin ÊúâÊâÄÊúâÊ¨äÈôê
        if "*" in user_permissions:
            return True
        
        return permission in user_permissions
    
    def batch_update_users(self, user_ids: List[int], updates: Dict[str, Any]) -> int:
        """ÊâπÈáèÊõ¥Êñ∞Áî®Êà∂"""
        success_count = 0
        with self.lock:
            for user_id in user_ids:
                if self.update_user(user_id, updates):
                    success_count += 1
        return success_count
    
    def get_user_statistics_by_role(self) -> Dict[str, int]:
        """ÊåâËßíËâ≤Áµ±Ë®àÁî®Êà∂Êï∏Èáè"""
        try:
            if self.mode == "adapter":
                results = self.db.execute_query('''
                    SELECT role, COUNT(*) as count 
                    FROM users 
                    GROUP BY role
                ''')
                return {row['role']: row['count'] for row in results}
            else:
                with self._get_db_connection() as conn:
                    rows = conn.execute('''
                        SELECT role, COUNT(*) as count 
                        FROM users 
                        GROUP BY role
                    ''').fetchall()
                    return {row[0]: row[1] for row in rows}
        except Exception as e:
            safe_print(f"‚ùå ÊåâËßíËâ≤Áµ±Ë®àÂ§±Êïó: {e}")
            return {}
    
    def get_recent_user_activity(self, days: int = 7) -> List[Dict]:
        """Áç≤ÂèñÊúÄËøëÁî®Êà∂Ê¥ªÂãï"""
        try:
            cutoff_date = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')
            
            if self.mode == "adapter":
                results = self.db.execute_query('''
                    SELECT 
                        u.username,
                        u.last_login,
                        COUNT(a.id) as activity_count
                    FROM users u
                    LEFT JOIN audit_logs a ON u.id = a.user_id 
                        AND DATE(a.timestamp) >= ?
                    WHERE u.is_active = 1
                    GROUP BY u.id, u.username, u.last_login
                    ORDER BY activity_count DESC, u.last_login DESC
                    LIMIT 20
                ''', (cutoff_date,))
                
                return [
                    {
                        "username": row['username'],
                        "last_login": row['last_login'],
                        "activity_count": row['activity_count']
                    }
                    for row in results
                ]
            else:
                with self._get_db_connection() as conn:
                    rows = conn.execute('''
                        SELECT 
                            u.username,
                            u.last_login,
                            COUNT(a.id) as activity_count
                        FROM users u
                        LEFT JOIN audit_logs a ON u.id = a.user_id 
                            AND DATE(a.timestamp) >= ?
                        WHERE u.is_active = 1
                        GROUP BY u.id, u.username, u.last_login
                        ORDER BY activity_count DESC, u.last_login DESC
                        LIMIT 20
                    ''', (cutoff_date,)).fetchall()
                    
                    return [
                        {
                            "username": row[0],
                            "last_login": row[1],
                            "activity_count": row[2]
                        }
                        for row in rows
                    ]
        except Exception as e:
            safe_print(f"‚ùå Áç≤ÂèñÁî®Êà∂Ê¥ªÂãïÂ§±Êïó: {e}")
            return []
    
    def close(self):
        """ÈóúÈñâÊï∏ÊìöÂ∫´ÈÄ£Êé•"""
        if self.mode == "adapter" and self.db:
            self.db.disconnect()

# ÂâµÂª∫Áî®Êà∂ÁÆ°ÁêÜÂô®ÂØ¶‰æã
try:
    user_manager = CompatibleUserManager(db_file="user_management.db")
    safe_print("‚úÖ Â¢ûÂº∑ÁâàÁî®Êà∂ÁÆ°ÁêÜÂô®ÂàùÂßãÂåñÊàêÂäü")
except Exception as e:
    safe_print(f"‚ùå Áî®Êà∂ÁÆ°ÁêÜÂô®ÂàùÂßãÂåñÂ§±Êïó: {e}")
    user_manager = None

# Â∞éÂá∫
__all__ = ["User", "Session", "AuditLog", "CompatibleUserManager", "user_manager"]